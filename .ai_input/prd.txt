Product Requirements Document (PRD)
WireGuard Gateway Web App

⸻

1. Purpose & Background

Enterprises and advanced home users operating multiple remote sites often rely on WireGuard VPN tunnels to interconnect networks. Manually configuring and maintaining these tunnels, NAT/forwarding rules, and router routes is time-consuming and error-prone. This web application will streamline:
	•	Uploading and validating WireGuard client configs
	•	Activating/deactivating tunnels
	•	Applying NAT and forwarding rules automatically
	•	Generating router route instructions
	•	Monitoring tunnel health and gateway performance

No user authentication is required for this initial MVP; focus is purely on the WireGuard gateway management features.

⸻

2. Objectives
	1.	Simplify WireGuard client onboarding: upload .conf, validate and sanitize AllowedIPs.
	2.	Automate kernel IP forwarding and iptables rules per client.
	3.	Expose actionable route commands for the network’s main router.
	4.	Monitor handshake times, connectivity (ping), CPU & RAM usage.
	5.	Provide a clean dashboard for lifecycle management (view, activate, deactivate, delete).

⸻

3. Scope

In-Scope
	•	Single-user web interface on the WireGuard gateway device.
	•	Upload/manage multiple client configs.
	•	Apply/remove NAT/forwarding rules.
	•	Real-time status display (last handshake, ping).
	•	Display gateway device CPU & RAM usage.
	•	Generate router route commands for each client subnet.

Out-of-Scope
	•	Multi-user authentication/authorization
	•	Site-to-site bi-directional routing (no B↔A or B↔C traffic)
	•	Automated router API integration (static CLI instructions only)
	•	Persistent user sessions or audit logs

⸻

4. Stakeholders
	•	Network Administrator: primary user; wants GUI to replace manual shell scripts.
	•	IT Operations: monitors gateway health.
	•	Systems Integrator: may build on API hooks for other automations.

⸻

5. User Flows & Wireframes

5.1 Onboarding a New Client
	1.	Upload Config
	•	User selects a .conf file.
	•	System parses [Interface] and [Peer] sections.
	•	If AllowedIPs = 0.0.0.0/0, prompt user to enter the specific subnet (e.g. 192.168.2.0/24).
	2.	Save Config
	•	Store file path (e.g. /etc/wireguard/CLIENT_NAME.conf).
	•	Record metadata: client name, peer public key, subnet.
	3.	Activate Client
	•	wg-quick up CLIENT_NAME.conf
	•	Enable net.ipv4.ip_forward.
	•	Apply iptables rules (see Section 6).
	•	Perform connectivity test (ICMP ping to a known host in that subnet).
	4.	Generate Router Command
	•	Display: ip route add 192.168.X.0/24 via 192.168.1.2 dev enp3s0

<details>
<summary>Wireframe Sketch</summary>


+------------------------------------------------+
| [Upload Config]                                |
| [Filename: _____] [Browse] [Upload & Validate] |
+------------------------------------------------+
| If invalid: “AllowedIPs cannot be 0.0.0.0/0.    |
|  Please specify client subnet: [_____]         |
|  [Save]                                        |
+------------------------------------------------+

</details>


5.2 Dashboard & Client Management
	•	Table View:

Client Name	Subnet	Status	Last Handshake	Actions
SITEB	192.168.2.0/24	Active	2025-04-24 10:15	[Deactivate] [View] [Delete]
SITEC	192.168.3.0/24	Inactive	—	[Activate] [View] [Delete]


	•	Client Details view shows:
	•	Full .conf contents (read-only)
	•	NAT/Forwarding iptables rules applied
	•	Generated router route command
	•	Historical ping times (last 5 tests)

⸻

6. Functional Requirements

#	Requirement
F1	Config Upload & Validation: Accept .conf files; parse and validate AllowedIPs.
F2	Subnet Prompt: If 0.0.0.0/0 is present, disallow and prompt for specific subnet input.
F3	Activate/Deactivate: Run wg-quick up/down, manage kernel forwarding flag.
F4	Iptables Management: Add/remove NAT (POSTROUTING MASQUERADE on peer interface) and FORWARD rules.
F5	Connectivity Tests: On activation, ping a representative host; record latency and success/failure.
F6	Route Instruction: Compute ip route add command for router pointing to gateway’s LAN IP.
F7	Dashboard: List all clients with status, last handshake, activation controls.
F8	Client Detail: Show config, routes, NAT rules, test history.
F9	System Metrics: Retrieve and display CPU & RAM usage (e.g., via /proc or top).



⸻

7. Technical Architecture

  [Web UI (React/Vue)]
           │ REST API (Flask/Express)
           ▼
  [Backend Service]───┐
      │              │
      ├─ WireGuard CLI Integration (wg-quick)  
      ├─ Iptables Manager (shell + python subprocess)  
      ├─ Config Store (filesystem + simple JSON metadata)  
      └─ Monitoring Module (ping tool + psutil)  

	•	Tech Stack
	•	Frontend: React or Vue.js
	•	Backend: Python 3.8 (Flask/FastAPI)
	•	Storage: Local FS for .conf; SQLite or JSON for metadata
	•	System calls: subprocess module for wg-quick and iptables

⸻

8. Data Model

Client:
  id: uuid
  name: string
  config_path: string
  subnet: string  # e.g. "192.168.2.0/24"
  public_key: string
  status: enum { active, inactive }
  last_handshake: datetime | null
  test_history: list of { timestamp, latency_ms, success }



⸻

9. Non-Functional Requirements
	•	Performance: UI actions (activate, deactivate) must complete in <5 seconds.
	•	Reliability: Changes to iptables must be atomic; roll back on failure.
	•	Usability: Clear error messages; minimal clicks to activate a client.
	•	Security:
	•	Run backend processes with least privileges.
	•	Validate all user inputs (esp. subnet strings) to prevent shell injection.
	•	Store configs with appropriate filesystem permissions (600).
	•	Maintainability:
	•	Follow PEP 8 & PEP 257 for Python.
	•	Document key modules and functions.

⸻

10. Acceptance Criteria
	1.	Upload: Uploading a .conf with 0.0.0.0/0 is blocked; custom subnet is required.
	2.	Activate: Activating adds correct iptables rules (verify with iptables -t nat -L).
	3.	Connectivity: Ping test runs automatically; results are displayed.
	4.	Routes: System shows correct ip route add command for router.
	5.	Dashboard: All clients listed with correct status and last handshake.
	6.	Metrics: CPU & RAM usage refresh every 30 seconds.

This is done Manually today like that:

1.	sudo apt install wireguard wireguard-tools
2.	Run   sudo apt install resolvconf
3.	sudo wg-quick up /home/yair/VPN-TESTING/SIXT.conf
4.	sudo wg-quick up /home/yair/VPN-TESTING/YES.conf
5.	remove from the .conf the 0.0.0.0/0 and add instead the subnet of the client we want for example 192.168.101.0/24
6.    sudo sysctl -w net.ipv4.ip_forward=1
7.	Setup NAT and Forwarding rules:
sudo iptables -t nat -A POSTROUTING -o SITEB -j MASQUERADE
sudo iptables -t nat -A POSTROUTING -o SITEC -j MASQUERADE

sudo iptables -A FORWARD -i enp3s0 -o SITEB -j ACCEPT
sudo iptables -A FORWARD -i enp3s0 -o SITEC -j ACCEPT

sudo iptables -A FORWARD -i SITEB -o enp3s0 -m state --state RELATED,ESTABLISHED -j ACCEPT
sudo iptables -A FORWARD -i SITEC -o enp3s0 -m state --state RELATED,ESTABLISHED -j ACCEPT
8.	sudo apt install iptables-persistent
sudo netfilter-persistent save
9. 	Setup on my router the routes for any traffic to site b and c via the WireGuard.

